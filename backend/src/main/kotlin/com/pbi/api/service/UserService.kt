package com.pbi.api.service

import com.pbi.api.domain.BusinessProfile
import com.pbi.api.domain.IndividualProfile
import com.pbi.api.domain.User
import com.pbi.api.domain.UserType
import com.pbi.api.exception.*
import com.pbi.api.repository.BusinessProfileRepository
import com.pbi.api.repository.IndividualProfileRepository
import com.pbi.api.repository.UserRepository
import com.pbi.api.repository.UserWithProfile
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.reactive.TransactionalOperator
import org.springframework.transaction.reactive.executeAndAwait
import java.time.LocalDateTime
import java.util.*

@Service
class UserService(
    private val userRepository: UserRepository,
    private val businessProfileRepository: BusinessProfileRepository,
    private val individualProfileRepository: IndividualProfileRepository,
    private val passwordEncoder: PasswordEncoder,
    private val transactionalOperator: TransactionalOperator,
    private val tokenService: TokenService,
    private val emailService: EmailService
) {

    suspend fun authenticationFindById(id: UUID): User? {
        return userRepository.findByIdOrEmailWithRolesAndPermissions(id)
    }

    suspend fun findByEmail(email: String): User? {
        return userRepository.findByEmail(email)
    }

    suspend fun findUserWithProfile(id: UUID): UserWithProfile? {
        return userRepository.findUserWithProfile(id)
    }

    suspend fun createUser(
        name: String,
        email: String,
        password: String,
        userType: UserType,
        linkedinId: String? = null
    ): User {
        // Check if user already exists
        if (userRepository.existsByEmail(email)) {
            throw UserAlreadyExistsException("User with email $email already exists")
        }

        val hashedPassword = passwordEncoder.encode(password)
        val verificationToken = tokenService.generateVerificationToken()
        val now = LocalDateTime.now()

        val user = User(
            id = UUID(0, 0), // Will be generated by database
            email = email,
            passwordHash = hashedPassword,
            userType = userType,
            linkedinId = linkedinId,
            verificationToken = verificationToken,
            createdAt = now,
            updatedAt = now
        )

        val savedUser = userRepository.save(user)

        emailService.sendVerificationEmail(email, verificationToken, name)
        return savedUser
    }

    suspend fun createBusinessUser(
        email: String,
        password: String,
        companyName: String,
        companyEmail: String,
        companyPhone: String?,
        personalName: String,
        personalEmail: String,
        registrationCountry: String,
        residenceCountry: String?,
        biography: String? = null
    ): UserWithProfile {
        // Validate business registration requirements
        validateBusinessRegistration(
            companyName, companyEmail, personalName, personalEmail, registrationCountry
        )

        return transactionalOperator.executeAndAwait {
            // Create the user
            val user = createUser(companyName, email, password, UserType.BUSINESS)

            // Note: User is NOT activated until email verification

            // Create business profile
            val businessProfile = BusinessProfile(
                id = UUID(0, 0), // Will be generated by database
                userId = user.id,
                companyName = companyName,
                companyEmail = companyEmail,
                companyPhone = companyPhone,
                ownerName = personalName,
                ownerPersonalEmail = personalEmail,
                biography = biography,
                registrationCountry = registrationCountry,
                residenceCountry = residenceCountry,
                location = null,
                profileImageUrl = null,
                coverImageUrl = null,
                deletedAt = null,
                createdAt = LocalDateTime.now(),
                updatedAt = LocalDateTime.now()
            )

            val savedProfile = businessProfileRepository.save(businessProfile)

            UserWithProfile(user, businessProfile = savedProfile)
        }
    }

    suspend fun createIndividualUser(
        email: String,
        password: String,
        name: String,
        phone: String?,
        nationality: String,
        residenceCountry: String?,
        biography: String? = null
    ): UserWithProfile {
        // Validate individual registration requirements
        validateIndividualRegistration(name, nationality)

        return transactionalOperator.executeAndAwait {
            // Create the user
            val user = createUser(name, email, password, UserType.INDIVIDUAL)

            // Note: User is NOT activated until email verification

            // Create individual profile
            val individualProfile = IndividualProfile(
                id = UUID(0, 0), // Will be generated by database
                userId = user.id,
                name = name,
                phone = phone,
                biography = biography,
                nationality = nationality,
                residenceCountry = residenceCountry,
                location = null,
                profileImageUrl = null,
                coverImageUrl = null,
                deletedAt = null,
                createdAt = LocalDateTime.now(),
                updatedAt = LocalDateTime.now()
            )

            val savedProfile = individualProfileRepository.save(individualProfile)

            UserWithProfile(user, individualProfile = savedProfile)
        }
    }

    private fun validateBusinessRegistration(
        companyName: String,
        companyEmail: String,
        personalName: String,
        personalEmail: String,
        registrationCountry: String
    ) {
        if (companyName.isBlank()) {
            throw ValidationException("Company name is required")
        }
        if (companyName.length < 2) {
            throw ValidationException("Company name must be at least 2 characters long")
        }
        if (companyName.length > 255) {
            throw ValidationException("Company name must not exceed 255 characters")
        }

        if (companyEmail.isBlank()) {
            throw ValidationException("Company email is required")
        }
        if (!isValidEmail(companyEmail)) {
            throw ValidationException("Invalid company email format")
        }

        if (personalName.isBlank()) {
            throw ValidationException("Personal name is required")
        }
        if (personalName.length < 2) {
            throw ValidationException("Personal name must be at least 2 characters long")
        }

        if (personalEmail.isBlank()) {
            throw ValidationException("Personal email is required")
        }
        if (!isValidEmail(personalEmail)) {
            throw ValidationException("Invalid personal email format")
        }

        if (registrationCountry.isBlank()) {
            throw ValidationException("Registration country is required")
        }
        if (registrationCountry.length < 2) {
            throw ValidationException("Registration country must be at least 2 characters long")
        }
    }

    private fun validateIndividualRegistration(name: String, nationality: String) {
        if (name.isBlank()) {
            throw ValidationException("Name is required")
        }
        if (name.length < 2) {
            throw ValidationException("Name must be at least 2 characters long")
        }
        if (name.length > 255) {
            throw ValidationException("Name must not exceed 255 characters")
        }

        if (nationality.isBlank()) {
            throw ValidationException("Nationality is required")
        }
        if (nationality.length < 2) {
            throw ValidationException("Nationality must be at least 2 characters long")
        }
    }

    private fun isValidEmail(email: String): Boolean {
        return email.matches(Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"))
    }

    suspend fun authenticateUser(email: String, password: String): User? {
        val user = userRepository.findByIdOrEmailWithRolesAndPermissions(email = email) ?: return null

        if (user.passwordHash == null || !passwordEncoder.matches(password, user.passwordHash)) {
            return null
        }

        // Check if user is activated
        if (user.activatedAt == null) {
            throw UserNotActivatedException("User account is not activated")
        }

        return user
    }

    suspend fun activateUser(userId: UUID): User? {
        val user = userRepository.findById(userId) ?: return null

        if (user.activatedAt != null) {
            throw UserAlreadyActivatedException("User is already activated")
        }

        userRepository.updateActivationStatus(userId, LocalDateTime.now())
        return userRepository.findById(userId)
    }

    suspend fun verifyEmail(token: String): User? {
        val (id, email, userType, createdAt, verifiedAt, name) = userRepository.findByVerificationToken(token)
            ?: throw TokenNotFoundException("Invalid verification token")

        // Check if token is expired
        if (createdAt == null) {
            throw TokenExpiredException("Verification token has expired")
        }

        if (tokenService.isVerificationTokenExpired(createdAt)) {
            throw TokenExpiredException("Verification token has expired")
        }

        // Check if user is already verified
        if (verifiedAt != null) {
            throw UserAlreadyActivatedException("User is already verified")
        }

        // Mark user as verified and activated
        val now = LocalDateTime.now()
        userRepository.updateVerificationStatus(id!!, now, now)

        emailService.sendWelcomeEmail(email!!, name!!, userType ?: "USER")

        return userRepository.findById(id)
    }

    suspend fun updatePassword(userId: UUID, oldPassword: String, newPassword: String): Boolean {
        val user = userRepository.findById(userId) ?: return false

        if (user.passwordHash == null || !passwordEncoder.matches(oldPassword, user.passwordHash)) {
            return false
        }

        val hashedNewPassword = passwordEncoder.encode(newPassword)
        userRepository.updatePassword(userId, hashedNewPassword)
        return true
    }

    suspend fun resetPassword(email: String): Boolean {
        val (id, activatedAt, name) = userRepository.findByEmailToReset(email) ?: return false

        // Check if user is activated
        if (activatedAt == null) {
            throw UserNotActivatedException("User account is not activated")
        }

        val resetToken = tokenService.generatePasswordResetToken()
        val resetTokenExpiresAt = tokenService.getPasswordResetTokenExpiration()

        // Save reset token to user
        userRepository.updatePasswordResetToken(id!!, resetToken, resetTokenExpiresAt)

        emailService.sendPasswordResetEmail(email, resetToken, name ?: "User")

        return true
    }

    suspend fun confirmPasswordReset(token: String, newPassword: String): Boolean {
        val user = userRepository.findByPasswordResetToken(token)
            ?: throw TokenNotFoundException("Invalid password reset token")

        // Check if token is expired
        if (user.resetPasswordExpiresAt == null) {
            throw TokenExpiredException("Password reset token has expired")
        }

        if (tokenService.isPasswordResetTokenExpired(user.resetPasswordExpiresAt)) {
            throw TokenExpiredException("Password reset token has expired")
        }

        // Update password and clear reset token
        val hashedNewPassword = passwordEncoder.encode(newPassword)
        userRepository.updatePasswordAndClearResetToken(user.id, hashedNewPassword)

        return true
    }
}

 